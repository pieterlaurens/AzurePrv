// Copyright (c) Deloitte Innovation. All rights reserved.
//
// Remark: this is a clone of the DeloitteEngine.Utilities.HttpRequestCrcCheck

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;

namespace Deloitte.PipelineFramework
{
    /// <summary>
    /// Class to create and validate a random key with a timestamp built in.
    /// </summary>
    public class HttpRequestCrcCheck
    {
        const string Alfa = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
        const string AlfaNum = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        const string Num = "0123456789-";
        List<int[]> KeysAtList = new List<int[]>() {
            new int[] { 2, 3, 6, 13 },
            new int[] { 0, 3, 5, 13 },
            new int[] { 2, 7, 8, 9 },
            new int[] { 0, 1, 6, 17, 18 },
            new int[] { 0, 10, 11, 17, 18, 26 },
            new int[] { 0, 2, 3, 12, 18, 25 },
        };

        /// <summary>
        /// Creates a random key.
        /// </summary>
        /// <param name="validTill">A DateTime that indicates the time the key expires.</param>
        /// <returns>The generated key.</returns>
        public string MakeKey(DateTime validTill)
        {
            var random = new Random();
            var key = string.Empty;
            var keyIndex = random.Next(0, KeysAtList.Count - 1);
            var keysAt = KeysAtList[keyIndex];
            for (int i = 0; i < 32; i++)
            {
                if (keysAt.Contains(i))
                {
                    key += Alfa[random.Next(0, Alfa.Length - 1)];
                }
                else {
                    key += AlfaNum[random.Next(0, AlfaNum.Length - 1)];
                }
            }
            key += keyIndex.ToString("X2", CultureInfo.InvariantCulture.NumberFormat);
            foreach(int pos in keysAt)
            {
                key += Alfa.IndexOf(key[pos]).ToString("X2", CultureInfo.InvariantCulture.NumberFormat);
            }
            int startPos = 20 + keysAt.Length;
            var binTill = validTill.ToBinary().ToString();
            key += binTill.Length.ToString("X2", CultureInfo.InvariantCulture.NumberFormat);
            foreach(char t in binTill)
            {
                key += AlfaNum[startPos + Num.IndexOf(t)];
            }
            for (int i = 0; i < random.Next(2,7); i++)
            {
                key += AlfaNum[random.Next(0, AlfaNum.Length - 1)];
            }
            return key;
        }

        /// <summary>
        /// Validates if a key is generated by this class and checks
        /// that the built-in timestamp is still later that the current
        /// time.
        /// </summary>
        /// <param name="key">The key to check.</param>
        /// <returns>True when the key is ok.</returns>
        public bool ValidateKey(string key)
        {
            bool valid = false;
            if (!string.IsNullOrEmpty(key) && key.Length > 40)
            {
                string alpha = key.Substring(0, 32);
                int keyIndex;
                int curIdx = 32;
                if (int.TryParse(
                    key.Substring(curIdx, 2), 
                    NumberStyles.HexNumber,
                    CultureInfo.InvariantCulture.NumberFormat,
                    out keyIndex
                ))
                {
                    curIdx += 2;
                    var keysAt = KeysAtList[keyIndex];
                    //check key
                    int alfaIdx;
                    for (int i = 0; i < keysAt.Length; i++)
                    {
                        valid = int.TryParse(
                                key.Substring(curIdx, 2), 
                                NumberStyles.HexNumber, 
                                CultureInfo.InvariantCulture.NumberFormat, 
                                out alfaIdx
                            )
                            && Alfa[alfaIdx].Equals(alpha[keysAt[i]])
                            ;
                        curIdx += 2;
                        if (!valid) break;
                    }
                    if (valid)
                    {
                        int startPos = 20 + keysAt.Length;
                        int timeStringLength;
                        valid = int.TryParse(
                            key.Substring(curIdx, 2),
                            NumberStyles.HexNumber,
                            CultureInfo.InvariantCulture.NumberFormat,
                            out timeStringLength
                        );
                        if (valid)
                        {
                            curIdx += 2;
                            var binary = string.Empty;
                            for (int t = curIdx; t < curIdx + timeStringLength; t++)
                            {
                                binary += Num[AlfaNum.IndexOf(key[t]) - startPos];
                            }
                            curIdx += timeStringLength;

                            long longBin;
                            valid = long.TryParse(binary, out longBin);
                            if (valid)
                            {
                                DateTime till = DateTime.FromBinary(longBin);
                                valid = till > DateTime.Now;
                            }
                        }
                    }
                }
            }
            return valid;
        }
    }
}
